### CAP√çTULO 5 ‚Äì Consultas Avan√ßadas: Extraindo *Insights* de Dados Relacionados

O comando `SELECT` √© a principal instru√ß√£o para consultas em um sistema de banco de dados, sendo uma das cl√°usulas mais simples e, ao mesmo tempo, mais extensas da SQL devido √† sua ortogonalidade e √†s suas diversas fun√ß√µes, operadores e cl√°usulas n√£o obrigat√≥rias. A Consulta Avan√ßada permite ir al√©m das buscas simples e √© essencial para extrair *insights* e relat√≥rios complexos dos dados armazenados.

üñ•Ô∏è **Ferramenta:** pgAdmin (PostgreSQL)

O **pgAdmin** √© a interface (*front-end*) que facilita o uso da SQL no SGBD PostgreSQL. As consultas apresentadas neste cap√≠tulo utilizam comandos SQL padronizados (ISO/IEC 9075), que s√£o reconhecidos por SGBDs relacionais como o PostgreSQL.

## 5.1 Jun√ß√µes (JOINs) e Relacionamentos entre Tabelas.

Quando um banco de dados √© submetido ao processo de **normaliza√ß√£o**, a informa√ß√£o de um tipo de entidade pode ser distribu√≠da por duas ou mais tabelas no modelo l√≥gico. O comando `JOIN` permite **juntar** os dados distribu√≠dos por m√∫ltiplas tabelas, apresentando-os no resultado de um √∫nico `SELECT`.

√â importante notar a diferen√ßa fundamental entre `JOIN` e `UNION`: no comando `JOIN`, cada registro resultante √© composto por atributos provenientes de duas ou mais tabelas relacionadas. J√° no comando `UNION`, cada registro mostrado pertence a apenas uma tabela, mas os resultados de duas ou mais tabelas s√£o combinados verticalmente.

A cl√°usula `JOIN` √© usada junto com uma **condi√ß√£o de jun√ß√£o** (operador `ON`) que combina as tuplas das tabelas sempre que o valor de um atributo em uma tabela for igual ao valor de um atributo na outra (geralmente via chaves prim√°rias/estrangeiras).

### Tipos de Jun√ß√µes (JOINs)

1.  **INNER JOIN (Jun√ß√£o Interna):** Com a cl√°usula `INNER`, o resultado da consulta incluir√° apenas os registros que possuem refer√™ncias correspondentes em **ambas** as tabelas envolvidas na jun√ß√£o. Se a palavra-chave `INNER` for omitida, a jun√ß√£o padr√£o √© o *Inner Join*.
2.  **OUTER JOIN (Jun√ß√£o Externa):** Com a cl√°usula `OUTER`, ser√£o mostrados os registros que tenham **ou n√£o** refer√™ncia nas tabelas.

    *   **LEFT OUTER JOIN:** Mostra **todos** os registros da tabela listada √† esquerda do `JOIN` (primeira tabela), preenchendo com valores nulos (`NULL`) os atributos da tabela da direita onde n√£o houver correspond√™ncia.
    *   **RIGHT OUTER JOIN:** Mostra **todos** os registros da tabela listada √† direita do `JOIN` (segunda tabela), preenchendo com nulos os atributos da tabela da esquerda onde n√£o houver correspond√™ncia.
    *   **FULL OUTER JOIN:** Mostra **todos** os registros de ambas as tabelas envolvidas, independentemente de haver correspond√™ncia, preenchendo com nulos onde a correspond√™ncia n√£o existir.

## 5.2 Fun√ß√µes de Agrega√ß√£o, Agrupamentos (GROUP BY) e Filtragem Avan√ßada (HAVING).

A SQL oferece fun√ß√µes de agrega√ß√£o, que s√£o utilizadas para sumarizar informa√ß√µes de m√∫ltiplas tuplas (registros) em uma √∫nica tupla de resumo.

**Fun√ß√µes de Agrega√ß√£o Principais (podem ser usadas na cl√°usula `SELECT`):**

*   `COUNT`: Retorna o n√∫mero total de registros na sele√ß√£o.
*   `SUM`: Retorna o somat√≥rio dos valores de um campo num√©rico.
*   `AVG`: Retorna a m√©dia aritm√©tica dos valores de um campo num√©rico.
*   `MAX`: Retorna o valor mais alto (m√°ximo) de um campo.
*   `MIN`: Retorna o valor mais baixo (m√≠nimo) de um campo.

### Cl√°usula GROUP BY

Quando se deseja aplicar fun√ß√µes de agrega√ß√£o a subgrupos de tuplas em uma rela√ß√£o (em vez de aplicar √† tabela inteira), utiliza-se a cl√°usula `GROUP BY`. Esta cl√°usula particiona as tabelas em conjuntos de tuplas sem sobreposi√ß√£o (grupos), com base nos valores de um ou mais atributos. Os atributos especificados na cl√°usula `GROUP BY` devem tamb√©m aparecer na cl√°usula `SELECT`.

### Cl√°usula HAVING

A cl√°usula `HAVING` √© utilizada para filtrar os resultados de uma ou mais fun√ß√µes agrupadas pela cl√°usula `GROUP BY`, pois o `WHERE` n√£o pode ser usado para impor condi√ß√µes sobre fun√ß√µes de agrega√ß√£o em grupos.

O `HAVING` testa as propriedades de grupo envolvendo fun√ß√µes agregadas, enquanto o `WHERE` restringe os resultados obtidos antes que os grupos sejam formados.

## 5.3 Subconsultas e Operadores L√≥gicos.

### Subconsultas (Nested Queries)

A SQL permite que os resultados de uma consulta sejam utilizados para filtrar os dados de outra consulta, um processo conhecido como *Nested Queries* (Ninhos de Pesquisa). Uma subconsulta √© uma declara√ß√£o `SELECT` aninhada dentro de outra declara√ß√£o `SELECT`.

**Exemplo:** Selecionar clientes cuja `ID` esteja contida nos resultados de uma subconsulta que lista `ID`s de pedidos com valor superior a um limite.

### Operadores L√≥gicos

A cl√°usula `WHERE` (usada tanto em consultas simples quanto em subconsultas e comandos DML como `DELETE` e `UPDATE`) utiliza operadores l√≥gicos para combinar condi√ß√µes complexas:

*   **`AND` (E L√≥gico):** Retorna `VERDADEIRO` apenas se **todas** as condi√ß√µes enumeradas forem atendidas.
*   **`OR` (OU L√≥gico):** Retorna `VERDADEIRO` se **pelo menos uma** das condi√ß√µes for atendida.
*   **`NOT` (Nega√ß√£o):** Usado para negar uma condi√ß√£o.

**Regras de Preced√™ncia:** As condi√ß√µes complexas seguem uma ordem de preced√™ncia: express√µes entre par√™nteses t√™m a mais alta preced√™ncia, seguidas por operadores de compara√ß√£o, pelo `AND`, e, por √∫ltimo, pelo `OR`.

## 5.4 Criando Vis√µes e Consultas Reutiliz√°veis.

A DDL (Data Definition Language) inclui comandos que definem a estrutura, como o `CREATE VIEW`.

Uma **VIEW (Vis√£o)** √© um comando `SELECT` salvo dentro do banco de dados e funciona como uma **tabela virtual**.

**Vantagens da Cria√ß√£o de Views:**

*   **Simplifica√ß√£o de Consultas:** A `VIEW` simplifica o uso de comandos `SELECT` complexos, pois permite que comandos `SELECT` subsequentes sejam aplicados sobre ela, como se fosse uma tabela real.
*   **Seguran√ßa e Personaliza√ß√£o:** Possibilita mostrar ao usu√°rio uma vers√£o personalizada ou simplificada das tabelas do banco de dados, ou seja, pode descrever apenas partes dos dados.
*   **Reutiliza√ß√£o:** Salva consultas complexas, permitindo que a l√≥gica de extra√ß√£o de dados seja reutilizada sem reescrever o c√≥digo completo.

## 5.5 ESTUDO DE CASO: Relat√≥rios da Biblioteca (Empr√©stimos mais populares, Hist√≥rico de Atrasos).

Para realizar relat√≥rios complexos no contexto da Biblioteca, assumindo tabelas como `LIVRO`, `ALUNO`, e `EMPRESTIMO` (com chaves estrangeiras que ligam alunos e livros, al√©m de armazenar datas de empr√©stimo e devolu√ß√£o), utilizamos Jun√ß√µes e Fun√ß√µes de Agrega√ß√£o.

**1. Empr√©stimos Mais Populares (Agrega√ß√£o e Agrupamento)**
Para identificar quais livros foram emprestados mais vezes, √© necess√°rio contar os registros na tabela de empr√©stimos, agrupando pelo t√≠tulo do livro (requer `JOIN` entre `LIVRO` e `EMPRESTIMO`).

```sql
SELECT
    L.Titulo,
    COUNT(E.Codigo_Livro) AS Total_Emprestimos
FROM
    LIVRO AS L
JOIN
    EMPRESTIMO AS E ON L.Codigo = E.Codigo_Livro
GROUP BY
    L.Titulo
ORDER BY
    Total_Emprestimos DESC;
```

**2. Hist√≥rico de Atrasos (Condi√ß√µes Avan√ßadas e Jun√ß√µes)**
Um atraso ocorre quando a data de devolu√ß√£o real √© posterior √† data de devolu√ß√£o prevista (ou se a data real ainda √© `NULL`, mas a data prevista j√° passou).

```sql
SELECT
    A.Nome AS Nome_Aluno,
    L.Titulo AS Titulo_Livro,
    E.Data_Devolucao_Prevista,
    E.Data_Devolucao_Real
FROM
    ALUNO AS A
JOIN
    EMPRESTIMO AS E ON A.Matricula = E.Matricula_Aluno
JOIN
    LIVRO AS L ON E.Codigo_Livro = L.Codigo
WHERE
    E.Data_Devolucao_Real > E.Data_Devolucao_Prevista;
-- Ou para listar livros que deveriam ter sido devolvidos e ainda n√£o foram (l√≥gica dependente do SGBD):
-- WHERE E.Data_Devolucao_Real IS NULL AND E.Data_Devolucao_Prevista < CURRENT_DATE;
```

## 5.6 EXERC√çCIOS COMPLEMENTARES: Consultas complexas em dom√≠nios variados (Ex: An√°lise de vendas de um E-commerce).

Considerando um dom√≠nio de E-commerce com tabelas que separam dados de clientes e pedidos (um cliente faz v√°rios pedidos, 1:N), realize as seguintes consultas avan√ßadas:

**Cen√°rio Base Simplificado:** `CLIENTE` (CPF, Nome), `REGISTRO_VENDA` (ID, Cliente_CPF FK, Valor_total).

1.  **Valor M√©dio das Vendas:** Calcule o valor m√©dio (`AVG`) de todos os pedidos registrados.

    ```sql
    SELECT AVG(Valor_total) AS Valor_Medio_Vendas
    FROM REGISTRO_VENDA;
    ```

2.  **Agrupamento por Cliente com Filtragem (HAVING):** Recupere o nome e o CPF dos clientes, juntamente com o n√∫mero total de pedidos (`COUNT`), mas apenas para aqueles clientes que realizaram mais de 5 pedidos.

    ```sql
    SELECT
        C.Nome,
        C.CPF,
        COUNT(RV.ID) AS Numero_Total_Pedidos
    FROM
        CLIENTE AS C
    JOIN
        REGISTRO_VENDA AS RV ON C.CPF = RV.Cliente_CPF
    GROUP BY
        C.Nome, C.CPF
    HAVING
        COUNT(RV.ID) > 5;
    ```

## 5.7 EXERC√çCIOS INTEGRADOS: An√°lise Estat√≠stica de Dados Demogr√°ficos (Geografia) e Frequ√™ncia em Pr√°ticas Corporais (Ed. F√≠sica).

### 1. An√°lise Estat√≠stica de Dados Demogr√°ficos (Geografia)

Assumindo uma tabela `CIDADE` com informa√ß√µes demogr√°ficas (`Nome`, `Populacao`).

**Consulta:** Determine a menor popula√ß√£o registrada (`MIN`) e o total da popula√ß√£o (`SUM`) de todas as cidades no banco de dados.

```sql
SELECT
    MIN(Populacao) AS Menor_Populacao,
    SUM(Populacao) AS Populacao_Total
FROM
    CIDADE;
```

### 2. Frequ√™ncia em Pr√°ticas Corporais (Ed. F√≠sica)

Assumindo a modelagem l√≥gica do Cap√≠tulo 3.8: `TB_ALUNO` (Matricula, Nome) e `TB_REGISTRO_PRATICA` (Matricula_Aluno FK, Dura√ß√£o).

**Consulta:** Liste a m√©dia de dura√ß√£o das pr√°ticas corporais (`AVG(Dura√ß√£o)`) realizadas por cada aluno, ordenando o resultado pela m√©dia de forma decrescente.

```sql
SELECT
    A.Nome,
    AVG(RP.Dura√ß√£o) AS Media_Duracao_Pratica
FROM
    TB_ALUNO AS A
JOIN
    TB_REGISTRO_PRATICA AS RP ON A.Matricula = RP.Matricula_Aluno
GROUP BY
    A.Nome
ORDER BY
    Media_Duracao_Pratica DESC;
```
